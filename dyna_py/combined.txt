=== ../dyna/src/InputField.svelte ===
<script>
  export let label = "";
  export let name = "";
</script>

<label>
  {label}
  <input name={name} />
</label>


=== ../dyna/src/FormInterpreter.svelte ===
<script> 
    // Minimal flat schema: 
    // { type: 'text'|'number'|'select'|'checkbox', name: string, label?: string, options?: (string|{label,value})[] } 
    let { 
        value = $bindable({}),  
        schema = [],  
        disabled = false, 
        readOnly = false, 
        debug = false, 

    //    ({ value }) => void 
        onSubmit: onSubmitCb } = $props()



    function toOptions(opts) { 
        if (!opts) return []; 
        if (typeof opts[0] === 'string') 
            return opts.map((s) => ({ value: s, label: s })); 
        return opts; 
    } 

    function setField(name, type, raw) { 
        let v; 
        if (type === 'checkbox') 
            v = !!raw.checked; 
        else if (type === 'number') v = raw.value === '' ? null : Number(raw.value); 
        else v = raw.value; 
        // reassign to trigger binding 
        value = { ...value, [name]: v }; 
    } 

    function handleSubmit(e) { 
        e.preventDefault(); 
        if (typeof onSubmitCb === 'function') onSubmitCb({ value }); 
    } 
</script> 


<form onsubmit={handleSubmit}> 
    {#each schema as field, i (field.name ?? i)} 
        <div class="fi-field"> {#if field.label} <label for={field.name}>{field.label}</label> {/if}
            {#if field.type === 'select'}
                <select
                id={field.name}
                value={value[field.name] ?? ''}
                onchange={(e) => setField(field.name, 'select', e.currentTarget)}
                disabled={disabled}
                >
                <option value="" disabled selected={value[field.name] == null}>Select...</option>
                {#each toOptions(field.options) as opt}
                    <option value={opt.value} selected={String(opt.value) === String(value[field.name])}>
                    {opt.label}
                    </option>
                {/each}
                </select>

            {:else if field.type === 'checkbox'}
                <input
                id={field.name}
                type="checkbox"
                checked={!!value[field.name]}
                onchange={(e) => setField(field.name, 'checkbox', e.currentTarget)}
                disabled={disabled}
                readonly={readOnly}
                />

            {:else}
                <input
                id={field.name}
                type={field.type === 'number' ? 'number' : 'text'}
                value={value[field.name] ?? ''}
                oninput={(e) => setField(field.name, field.type, e.currentTarget)}
                disabled={disabled}
                readonly={readOnly}
                />
            {/if}
        </div>
    {/each}

    <button type="submit" disabled={disabled}>Submit</button>

    {#if debug}
        <pre>{JSON.stringify(value, null, 2)}</pre>
    {/if}

</form> 

<style> 
/* Form layout: stacked, predictable */ 
    form { 
        display: flex; 
        flex-direction: column; 
        gap: 14px; 
        align-content: start; 
        text-align: left; 
    } 
    .fi-field { 
        display: flex; 
        flex-direction: column; 
        gap: 6px; 
    } 
    /* Strong, left-aligned labels */ 
    .fi-field label { 
        font-weight: 700; 
        font-size: 0.9rem; 
        color: #334155; 
        /* slate-700 */ 
        letter-spacing: 0.01em; 
    } 
    /* Inputs + selects */ 
    input[type="text"], input[type="number"], select { 
        appearance: none; 
        width: 100%; 
        padding: 10px 12px; 
        border: 1px solid #d1d5db; 
        border-radius: 10px; 
        background: #fff; 
        color: #111827; 
        outline: none; 
        transition: border-color 120ms, box-shadow 120ms, background-color 120ms; 
        box-shadow: inset 0 1px 0 rgba(0,0,0,0.02); 
    } 
    input::placeholder { 
        color: #9ca3af; 
    } 
    input:focus, select:focus { 
        border-color: var(--fi-accent, #2563eb); 
        box-shadow: 0 0 0 3px rgba(37,99,235,0.20), inset 0 1px 0 rgba(255,255,255,0.4); 
    } 
    /* Select caret */ 
    select { 
        background-image: linear-gradient(45deg, transparent 50%, #6b7280 50%), linear-gradient(135deg, #6b7280 50%, transparent 50%); 
        background-position: calc(100% - 18px) 50%, calc(100% - 13px) 50%; 
        background-size: 6px 6px, 6px 6px; 
        background-repeat: no-repeat; 
        padding-right: 32px; 
    } 
    /* Checkbox row */ 
    .fi-field:has(input[type="checkbox"]) { 
        flex-direction: row; 
        align-items: center; 
        gap: 10px; 
    } 
    .fi-field:has(input[type="checkbox"]) input[type="checkbox"] { 
        width: 16px; 
        height: 16px; 
        accent-color: var(--fi-accent, #2563eb); 
    } 
    .fi-field:has(input[type="checkbox"]) label { 
        margin: 0; 
        user-select: none; 
        font-weight: 600; 
    } 
    /* Submit button (left aligned) */ 
    form > button[type="submit"] { 
        align-self: flex-start; 
        margin-top: 4px; 
        padding: 10px 14px; 
        border-radius: 10px; 
        border: 1px solid #1d4ed8; background: #2563eb; 
        color: #fff; 
        font-weight: 700; 
        cursor: pointer; 
        transition: filter 120ms ease, transform 80ms ease, box-shadow 120ms ease; box-shadow: 0 2px 8px rgba(37,99,235,0.25); 
        } 
    form > button[type="submit"]:hover { 
        filter: brightness(1.05); 
    } form > 
    button[type="submit"]:active { 
        transform: translateY(1px); 
    } 
    form > button[type="submit"]:disabled { 
        opacity: 0.6; cursor: not-allowed; box-shadow: none; 
    } 
    </style>


=== ../dyna/src/Canvas.svelte ===
<script> 
    import { WINDOW_RENDERERS } from './windows/registry.js'; 
    const CHAT_TYPES = ['default', 'support', 'analysis']; 
    // Props 
    let { 
        engine = { 
                    place({ windows, config, canvasSize }) { 
                        const offset = 28; 
                        const i = windows.length; 
                        return { 
                            x: 40 + (i * offset) % Math.max(1, (canvasSize?.w ?? 1200) - 480), 
                            y: 40 + (i * offset) % Math.max(1, (canvasSize?.h ?? 800) - 320), 
                            w: config?.size?.w ?? 420, h: config?.size?.h ?? 280 }; 
                    } 
        },

        controller = $bindable(null), 
        initial = [], 
        confirmOnDirtyClose = true, 
        persistDefault = 'destroy',
        transitions = true,
        onPromptCb = null,
        promptToSchema = null,
        promptPlaceholder = 'Describe a form you want to create…' 

        } = $props()


     // Make reassignable state into $state 
     let windows = $state([]); // you do windows = [...windows, ...] 
     let closed = $state(new Map()); 
     // if you mutate, reassign to notify 
     let zCounter = $state(1); // you do ++zCounter let canvasEl; // ref; no $state needed unless you reassign manually 

    let canvasEl; 
    let windowsLayerEl;
    let promptText = $state(''); 
    let working = $state(false);


    // Spawn initial windows if provided 
    $effect(() => { 
        if (Array.isArray(initial) && initial.length) { 
            for (const cfg of initial) spawn(cfg); 
        } 
    }); 

    // Controller API 
    function spawn(config) { 
        // config: { id?, title?, schema, value?, persist?, size?, position? } 
        const id = config.id ?? crypto.randomUUID?.() ?? `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`; 
        const schema = config.schema ?? []; 
        const value = config.value ?? {}; 
        const canvasSize = getCanvasSize(); 
        const placed = engine.place({ windows, config, canvasSize }) ?? {}; 
        const pos = config.position ?? { x: placed.x ?? 40, y: placed.y ?? 40 }; 
        const size = config.size ?? { w: placed.w ?? 420, h: placed.h ?? 280 }; 
        const persist = config.persist ?? persistDefault; 

        if (config.kind === 'chat') {
            const chatType = CHAT_TYPES.includes(config.chatType) ? config.chatType : 'default';
            const win = {
                id,
                kind: 'chat',
                title: config.title ?? 'Chat',
                messages: config.messages ?? [],
                chatConfig: config.chatConfig ?? {},
                position: pos,
                chatType,   
                size,
                z: ++zCounter,
                persist
            };
            windows = [...windows, win];
            return id;
        }



        if (config.kind === 'metadata') {
            const win = {
                id,
                kind: 'metadata',
                title: config.title ?? 'Metadata Editor',
                value: config.value ?? { entities: [] },
                position: pos,
                size,
                z: ++zCounter,
                persist
                };

            windows = [...windows, win];
            return id;
        }

        const win = {
            id,
            kind: 'form',
            title: config.title ?? 'Form',
            schema,
            value,
            position: pos,
            size,
            z: ++zCounter,
            persist
        };
        windows = [...windows, win];
        return id;
    }


    function getCanvasSize() { 
        const el = canvasEl; 
        if (!el) 
            return { w: 1200, h: 800 }; 
        const rect = el.getBoundingClientRect(); 
        return { w: rect.width, h: rect.height }; 
    }

     function focus(id) { 
        const idx = windows.findIndex((w) => w.id === id); 
        if (idx === -1) 
            return; 
        const w = windows[idx]; 
        w.z = ++zCounter; 
        windows = [...windows]; 
    }

     function close(id, { force = false } = {}) { 
        const idx = windows.findIndex((w) => w.id === id); 
        if (idx === -1) return; 
        const w = windows[idx]; 
        // Optional: honor force if you later add confirm logic here 
        if (w.persist === 'keep') { 
            closed.set(id, { 
                schema: w.schema, value: w.value, options: { 
                    title: w.title, 
                    size: w.size, 
                    position: w.position, 
                    persist: w.persist 
                } 
            }); 
        } 
        windows = windows.filter((win) => win.id !== id); 
    } 
     function reopen(id) { 
        if (!closed.has(id)) 
            return; 
        const entry = closed.get(id); 
        closed.delete(id); 
        spawn({ id, schema: entry.schema, value: entry.value, ...entry.options }); 
    } 
    function update(id, partial) { 
        const idx = windows.findIndex((w) => w.id === id); 
        if (idx === -1) 
            return; 
        windows[idx] = { ...windows[idx], ...partial }; 
        windows = [...windows]; 
    } 
    controller = { spawn, close, reopen, focus, update, list: () => windows.map((w) => ({ id: w.id, title: w.title })) }; 
     // Event handlers from FormWindow (callbacks passed as props) 
    function onRequestClose({ id, isDirty, value, persist, confirmOnDirtyClose: confirmFlag }) { 
        const needConfirm = confirmFlag ?? confirmOnDirtyClose; 
        if (needConfirm && isDirty) { 
            const ok = window.confirm('You have unsaved changes. Close anyway?'); 
            if (!ok) return; 
        } 
        if (persist === 'keep') { 
            const w = windows.find((w) => w.id === id); 
            if (w) { 
                closed.set(id, { schema: w.schema, value, options: { title: w.title, size: w.size, position: w.position, persist } }); 
            } 
        } 
        windows = windows.filter((w) => w.id !== id); 
    } 
    function onSubmit({ id, value }) { 
        // Hook for global handling (optional) // Example: console.log('Submit from', id, value); 
    } 
    function onFocus({ id }) { 
        focus(id); 
    } 

    // Prompt bar behavior 
    async function submitPrompt(e) { 
        e?.preventDefault?.(); 
        const text = promptText.trim(); 

        if (!text) return; 
        // Notify external listener first 
        if (typeof onPromptCb === 'function') { 
            try { 
                onPromptCb({ text, controller }); 
            } catch (_) {} } 
        if (typeof promptToSchema === 'function') { 
            working = true; 
            try { 
                const result = await promptToSchema(text, { 
                    canvasSize: getCanvasSize(), windows: [...windows], controller 
                });
                console.log(result) 

                const items = Array.isArray(result) ? result : (result ? [result] : []); 
                for (const cfg of items) {
                    if (!cfg || typeof cfg !== 'object') continue;
                    spawn(cfg); 
                } 
            } catch (err) { console.error('promptToSchema failed:', err); } 
            finally { working = false; promptText = ''; } 
        } 
        else { // No auto-spawn; just clear input 
            promptText = ''; 
        } 
    }
</script> 


<div class="canvas" bind:this={canvasEl}> 
    <div class="windows" bind:this={windowsLayerEl}>
        {#each windows as w (w.id)}
            {@const Renderer = WINDOW_RENDERERS[w.kind]} 
            {#if Renderer} 
                <Renderer w={w} onFocus={onFocus} onRequestClose={onRequestClose} onSubmit={onSubmit} transitions={transitions} /> 
            {:else} 
                <div class="window-unknown" style={`z-index:${w.z}`}> Unknown window kind: {w.kind} </div> 
            {/if}
        {/each}
    </div>
    <form class="promptbar" onsubmit={submitPrompt}>
        <input
            type="text"
            placeholder={promptPlaceholder}
            bind:value={promptText}
            disabled={working}
            aria-label="Describe a form to add to the canvas"
        />
        <button type="submit" disabled={working || !promptText.trim()}>
            {working ? 'Thinking…' : 'Create'}
        </button>
    </form> 
</div> 


<style> 
.canvas { 
    position: relative; 
    inline-size: 100%; 
    block-size: 100%; 
    overflow: hidden; 
    background: var(--canvas-bg, #f4f6f8); 
    /* Reserve space for footer using grid: top layer for windows, bottom for prompt */ 
    display: grid; 
    grid-template-rows: 1fr auto; 
} 
.windows { 
    position: relative; 
    /* Absolute children position within this area */ 
    inline-size: 100%; 
    block-size: 100%; 
    overflow: hidden; 
    /* Keep windows inside */ 
} 
.promptbar { 
    display: flex; 
    gap: 8px; 
    padding: 8px; 
    border-top: 1px solid #e2e8f0; 
    background: #ffffffcc; 
    backdrop-filter: blur(6px); 
} 
.promptbar input[type="text"] { 
    flex: 1; 
    padding: 10px 12px; 
    border: 1px solid #d1d5db; 
    border-radius: 10px; 
    background: #a29f9f; 
    outline: none; 
    transition: border-color 120ms, box-shadow 120ms; 
} 
.promptbar input[type="text"]:focus { 
    border-color: var(--fi-accent, #2563eb); 
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.20); 
} 
.promptbar button { 
    padding: 10px 14px; 
    border-radius: 10px; 
    border: 1px solid #1d4ed8; 
    background: #2563eb; 
    color: #fff; 
    font-weight: 700; 
    cursor: pointer; 
    transition: filter 120ms ease, transform 80ms ease, box-shadow 120ms ease; 
    box-shadow: 0 2px 8px rgba(37, 99, 235, 0.25); 
} 
.promptbar button:hover { 
    filter: brightness(1.05); 
} 
.promptbar button:active { 
    transform: translateY(1px); 
} 
.promptbar button:disabled { 
    opacity: 0.6; cursor: not-allowed; box-shadow: none; 
} 
</style>



=== ../dyna/src/ChatWindow.svelte ===
<script> 
    import WindowFrame from './WindowFrame.svelte'; 
    import ChatPanel from './ChatPanel.svelte'; 
    let { 
        id, 
        title = 'Chat', 
        messages = $bindable([]), 
        config = $bindable({}), 
        chatType = 'default',
        persist = 'keep', 
        position = $bindable({ x: 48, y: 48 }), 
        size = $bindable({ w: 520, h: 420 }), 
        z = 1, 
        onFocus: onFocusCb, 
        onRequestClose: onRequestCloseCb 
    } = $props(); 
    function requestClose() { 
        const inFlight = messages.some(m => m.meta?.streaming); 
        if (inFlight && !window.confirm('A reply is still generating. Stop and close?')) return; 
        onRequestCloseCb?.({ id, isDirty: false, value: { messages, config }, persist }); 
    } 
</script>


<WindowFrame
    id={id}
    title={title}
    bind:position={position}
    bind:size={size}
    z={z}
    onFocus={onFocusCb}
    onRequestClose={requestClose} >
    {#snippet children()}
        <ChatPanel bind:messages={messages} config={config} chatType={chatType} />
    {/snippet}

    {#snippet headerActions()}
        <button
            class="win-close"
            type="button"
            onpointerdown={(e) => e.stopPropagation()}
            onclick={requestClose}
            aria-label="Close"
        >×</button>
    {/snippet}
</WindowFrame>


=== ../dyna/src/ChatPanel.svelte ===

<script>
        
        let {
            messages = $bindable([]),
            config = $bindable({}),
            adapter = undefined,
            chatType = 'default'
        } = $props();

        let input = $state(''); 
        let sending = $state(false); 
        // drive UI 
        let canStop = $state(false); 
        // non-reactive internal handle 
        let abortCtrl; // AbortController | undefined 

        function append(role, content, meta = {}) { 
            const msg = { id: crypto.randomUUID?.() ?? String(Date.now()), role, content, ts: Date.now(), meta }; 
            messages = [...messages, msg]; 
            return msg.id; 
        } 
        async function send() { 
            const text = input.trim(); 
            if (!text || sending) return; 
            input = ''; 
            append('user', text); 
            sending = true; 
            abortCtrl = new AbortController(); 
            canStop = true; 
            const asstId = append('assistant', '', { streaming: true }); 
            try { 
                const client = adapter ?? defaultChatAdapter(); 
                for await (const chunk of client.stream({ messages, config, chatType, signal: abortCtrl.signal })) { 
                    const idx = messages.findIndex(m => m.id === asstId); 
                    if (idx >= 0) { 
                        messages[idx] = { ...messages[idx], content: (messages[idx].content ?? '') + chunk }; 
                        messages = [...messages]; 
                    } 
                } 
            } catch (err) { 
                const idx = messages.findIndex(m => m.id === asstId); 
                if (idx >= 0) { 
                    messages[idx] = { 
                        ...messages[idx], meta: { ...messages[idx].meta, error: String(err) } 
                    }; 
                    messages = [...messages]; 
                } 
            } 
            finally { 
                const idx = messages.findIndex(m => m.id === asstId); 
                if (idx >= 0) { 
                    messages[idx] = { ...messages[idx], meta: { ...messages[idx].meta, streaming: false } }; 
                    messages = [...messages]; 
                } 
                canStop = false; 
                abortCtrl = undefined; 
                sending = false; 
            } 
        } 
        function stop() { 
            abortCtrl?.abort(); 
            canStop = false; 
            abortCtrl = undefined; 
        } 

  // Example adapter: calls your server /api/chat for SSE/streaming
  function defaultChatAdapter() {
    return {
      async *stream({ messages, config, signal }) {
        const res = await fetch('http://localhost:5000/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ messages, config }),
          signal
        });
        const reader = res.body.getReader();
        const td = new TextDecoder();
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          const text = td.decode(value, { stream: true });
          // Assume server sends raw text chunks; adapt if using SSE/JSON
          yield text;
        }
      }
    };
  }

  function onKey(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      send();
    }
  }
</script>

<div class="chat">
  <div class="messages" data-scroller>
    {#each messages as m (m.id)}
      <div class="msg {m.role}">
        <div class="bubble">
          {m.content}
          {#if m.meta?.error}
            <div class="err">Error: {m.meta.error}</div>
          {/if}
        </div>
      </div>
    {/each}
    {#if sending}
      <div class="msg assistant"><div class="bubble typing">…</div></div>
    {/if}
  </div>


    <div class="composer"> 
        <textarea placeholder="Type a message…" bind:value={input} rows="1" onkeydown={onKey} disabled={sending && canStop}  > </textarea> 
        {#if sending && canStop} 
            <button type="button" onclick={stop}>Stop</button> 
        {:else} <button type="button" onclick={send} disabled={!input.trim() || sending}>Send</button> 
        {/if} 
    </div>

</div>

<style>
  .chat { display: grid; grid-template-rows: 1fr auto; height: 100%; }
  .messages { overflow: auto; padding: 8px; background: #c8a0a0; }
  .msg { display: flex; margin: 6px 0; }
  .msg.user { justify-content: flex-end; }
  .bubble { max-width: 70%; padding: 8px 10px; border-radius: 12px; background: #038e13; }
  .msg.user .bubble { background: #2563eb; color: #fff; }
  .typing { opacity: 0.6; }
  .err { margin-top: 6px; color: #b91c1c; font-size: 0.85em; }
  .composer { display: flex; gap: 8px; padding: 8px; border-top: 1px solid #e2e8f0; background: #fafafa; }
  textarea { flex: 1; resize: none; border: 1px solid #eef0f3; border-radius: 10px; padding: 10px 12px; outline: none; }
  textarea:focus { border-color: var(--fi-accent, #2563eb); box-shadow: 0 0 0 3px rgba(37,99,235,0.20); }
</style>


=== ../dyna/src/schema.js ===
export default {
  type: "form",
  fields: [
    { type: "input", label: "Name", name: "name" },
    {
      type: "group",
      label: "Details",
      fields: [
        { type: "input", label: "Age", name: "age" },
        { type: "input", label: "Email", name: "email" },
      ]
    },
    { type: "submit", label: "Save" }
  ]
};


=== ../dyna/src/App.svelte ===
<script> 
    import Canvas from './Canvas.svelte'; 
    let controller = null; 
    


    function clampNum(n, min, max, fallback) {
        const v = Number(n)
        return Number.isFinite(v) ? Math.min(max, Math.max(min, v)) : fallback
    }

    function sanitizeField(f) {
        if (!f || typeof f !== 'object') return null
        const allowed = ['text', 'number', 'select', 'checkbox']
        const type = allowed.includes(f.type) ? f.type : 'text'
        const name = String(f.name || '').trim()
        if (!name) return null
        const field = { type, name, label: String(f.label || name) }
        if (type === 'select') {
        let opts = Array.isArray(f.options) ? f.options : []
        opts = opts.map(o => typeof o === 'string' ? ({ value: o, label: o }) : o)
                    .filter(o => o && 'value' in o && 'label' in o)
        field.options = opts
        }
        return field
    }

    function sanitizeSpawnConfig(cfg) {
        if (!cfg || typeof cfg !== 'object') return null
        let kind = ['form', 'metadata', 'chat'].includes(cfg.kind) ? cfg.kind : 'form'
        const out = {
        kind,
        title: String(cfg.title || (kind === 'metadata' ? 'Metadata Editor' : kind === 'chat' ? 'Chat' : 'Form')),
        persist: cfg.persist === 'keep' ? 'keep' : 'destroy',
        size: {
            w: clampNum(cfg.size?.w, 320, 1200, 420),
            h: clampNum(cfg.size?.h, 200, 900, 280)
        },
        position: {
            x: clampNum(cfg.position?.x, 0, 4000, 40),
            y: clampNum(cfg.position?.y, 0, 4000, 40)
        }
        }
        if (kind === 'form') {
        out.schema = (Array.isArray(cfg.schema) ? cfg.schema.map(sanitizeField).filter(Boolean) : [])
        out.value = (cfg.value && typeof cfg.value === 'object') ? cfg.value : {}
        } else if (kind === 'metadata') {
        out.value = (cfg.value && typeof cfg.value === 'object') ? cfg.value : { entities: [] }
        } else if (kind === 'chat') {
        out.messages = Array.isArray(cfg.messages) ? cfg.messages : []
        out.chatConfig = (cfg.chatConfig && typeof cfg.chatConfig === 'object') ? cfg.chatConfig : {}
        }
        return out
    }


    async function promptToSchema(text /*, ctx */) {
        // Note: do not send ctx/controller to the server (least privilege)
        const ac = new AbortController()
        const timeout = setTimeout(() => ac.abort(), 15000) // 15s timeout
        try {
            const res = await fetch('http://127.0.0.1:5000/api/prompt-to-schema', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt: text }),
                signal: ac.signal
            })
            if (!res.ok) throw new Error(`HTTP ${res.status}`)
        
            const data = await res.json()
            console.log(data)

            const items = Array.isArray(data) ? data : [data]
        
            return items.map(sanitizeSpawnConfig).filter(Boolean)
        } finally {
        clearTimeout(timeout)
        }
    }

    /** 
    async function promptToSchema(text, ctx) { 
        return { 
            title: 'Metadata Editor', persist: 'keep', kind: 'metadata' ,
            value: { entities: [] } 
        }; 
    } 
    */

</script> 



<div class="toolbar"> 
    <button type="button" 
        onclick={() => controller?.spawn({ 
                            kind: 'plugin', 
                            title: 'Plugin: Hello', 
                            persist: 'keep', 
                            plugin: { id: 'hello.plugn', version: '1.0.0' }, 
                            props: { who: 'Canvas' }, 
                            size: { w: 420, h: 260 }, 
                            position: { x: 80, y: 80 } 
                        }) 
                        } > Open Hello Plugin </button> </div>

<div class="app"> 
    <div class="toolbar"> 
    </div> 
    <Canvas bind:controller={controller} transitions={true} {promptToSchema}/> 
</div> 



<style> 
    .app { 
        inline-size: 100vw; 
        block-size: 100vh; 
        display: grid; 
        grid-template-rows: auto 1fr; 
        background: #85b5e5; 
    } 
    .toolbar { 
        display: flex; 
        gap: 8px; 
        padding: 8px; 
        align-items: center; 
        border-bottom: 1px solid #e5e7eb; 
        background: #ea5e5e; 
    } 

</style>


=== ../dyna/src/main.js ===
import { mount } from 'svelte'
import './app.css'
import App from './App.svelte'

const app = mount(App, {
  target: document.getElementById('app'),
})

export default app


=== ../dyna/src/Attributes.svelte ===
<script> 
    let { 
        rows = $bindable([]), 
        disabled = false, 
        readOnly = false, 
        dataTypes = ['string', 'number', 'boolean', 'date', 'relation', 'GUID'], 
        uiControls = ['text', 'textarea', 'number', 'select', 'date', 'checkbox', 'table', 'relation'], 
        relTypes = ['one_to_one', 'one_to_many'] 
    } = $props(); 
    
    function addRow() { 
        const row = { 
            attribute_name: '', 
            data_type: 'string', 
            label: '', 
            required: false, 
            ui_control: 'text', 
            description: '', 
            parent_schema_name: null, 
            related_schema: null, 
            relation_type: null 
        }; 
        rows = [...rows, row]; 
    } 
    function del(i) { 
        rows = rows.filter((_, idx) => idx !== i); 
    } 
    function move(i, dir) { 
        const j = i + dir; 
        if (j < 0 || j >= rows.length) return; 
        const next = [...rows]; [next[i], next[j]] = [next[j], next[i]]; 
        rows = next; 
    } 
</script> 

<div class="attr-table"> 
    <div class="scroller"> 
        <table class="grid" role="grid" aria-label="Attributes"> 
            <colgroup> 
                <col style="width:150px" /> 
                <col style="width:130px" /> 
                <col style="width:150px" /> 
                <col style="width:90px" /> 
                <col style="width:130px" /> 
                <col style="width:200px" /> 
                <col style="width:180px" /> 
                <col style="width:220px" /> 
                <col style="width:160px" /> 
                <col style="width:140px" /> 
            </colgroup> 
            <thead> 
                <tr> 
                    <th>Attribute Name</th> 
                    <th>Data Type</th> 
                    <th>Label</th> 
                    <th>Required</th> 
                    <th>UI Control</th> 
                    <th>Description</th> 
                    <th>Parent Schema</th> 
                    <th>Related Schema</th> 
                    <th>Relation Type</th> 
                    <th></th> 
                </tr> 
            </thead> 
            <tbody> 
                {#each rows as a, idx (idx)} 
                    <tr> 
                        <td>
                            <input type="text" bind:value={a.attribute_name} disabled={disabled} readonly={readOnly} />
                        </td>
                        <td>
                        <select bind:value={a.data_type} disabled={disabled || readOnly}>
                            {#each dataTypes as t}<option value={t}>{t}</option>{/each}
                        </select>
                        </td>

                        <td><input type="text" bind:value={a.label} disabled={disabled} readonly={readOnly} /></td>

                        <td class="center">
                        <input class="chk" type="checkbox" bind:checked={a.required} disabled={disabled || readOnly} />
                        </td>

                        <td>
                            <select bind:value={a.ui_control} disabled={disabled || readOnly}>
                                {#each uiControls as u}<option value={u}>{u}</option>{/each}
                            </select>
                        </td>

                        <td><input type="text" bind:value={a.description} disabled={disabled} readonly={readOnly} /></td>

                        <td><input type="text" bind:value={a.parent_schema_name} placeholder="e.g., order" disabled={disabled} readonly={readOnly} /></td>

                        <td><input type="text" bind:value={a.related_schema} placeholder="e.g., order_line_items" disabled={disabled} readonly={readOnly} /></td>

                        <td>
                            <select bind:value={a.relation_type} disabled={disabled || readOnly}>
                                <option value={null}>—</option>
                                {#each relTypes as r}<option value={r}>{r}</option>{/each}
                            </select>
                        </td>

                        <td class="row-actions">
                        <button type="button" title="Up" onclick={() => move(idx, -1)} disabled={disabled || readOnly || idx === 0}>↑</button>
                        <button type="button" title="Down" onclick={() => move(idx, +1)} disabled={disabled || readOnly || idx === rows.length - 1}>↓</button>
                        <button type="button" title="Delete" onclick={() => del(idx)} disabled={disabled || readOnly}>✕</button>
                        </td>
                    </tr>
                {/each}

                {#if !rows || rows.length === 0}
                <tr><td class="empty" colspan="10">No attributes yet. Click “Add Attribute”.</td></tr>
                {/if}
            </tbody>
        </table>
    </div> 
    <div class="tfoot"> 
        <button type="button" class="primary" onclick={addRow} disabled={disabled || readOnly}>+ Add Attribute</button> 
    </div> 
</div> 

<style> 
    :root { 
        --mi-border: #e5e7eb; 
        --mi-subtle: #f8fafc; 
        --mi-text: #111827; 
        --mi-muted: #6b7280; 
        --mi-accent: var(--fi-accent, #2563eb); 
        --mi-accent-weak: rgba(37, 99, 235, 0.12); 
        --mi-radius: 10px; 
        --table-min-width: 1500px; 
        /* force H-scroll on narrow windows */ 
        --cell-pad-y: 8px; --cell-pad-x: 10px; --control-h: 36px; 
    } 
    .attr-table { 
        display: grid; 
        grid-template-rows: 1fr auto; 
        border: 1px solid var(--mi-border); 
        border-radius: var(--mi-radius); 
        background: #fff; 
        overflow: hidden; 
    } 
    .scroller { 
        overflow: auto; 
        /* both axes */ 
    } 
    table.grid { 
        width: 100%; 
        min-width: var(--table-min-width); 
        border-collapse: separate;
        border-spacing: 0; 
        
    } 
    thead th { 
        position: sticky; 
        top: 0; z-index: 1; 
        text-align: left; 
        background: var(--mi-subtle); 
        color: #374151; 
        font-weight: 700; 
        padding: 10px var(--cell-pad-x); 
        border-bottom: 1px solid var(--mi-border); 
    } 
    tbody td { 
        padding: var(--cell-pad-y) var(--cell-pad-x); 
        border-bottom: 1px solid #f3f4f6; 
        vertical-align: middle; background: #fff; 
    } 
    tbody tr:last-child td { 
        border-bottom: none; 
    } 
    .center { 
        text-align: center; 
    } 
    /* Controls */ 
    input[type="text"], select { 
        width: 100%; 
        height: var(--control-h); 
        padding: 8px 10px; 
        border: 1px solid #d1d5db; 
        border-radius: 8px; 
        background: #fff; 
        color: var(--mi-text); 
        outline: none; 
        transition: border-color 120ms, box-shadow 120ms, background-color 120ms; 
    } 
    input[type="text"]::placeholder { 
        color: #9ca3af; 
    } 
    input[type="text"]:focus, select:focus { 
        border-color: var(--mi-accent); box-shadow: 0 0 0 3px var(--mi-accent-weak); 
    } 
    input[readonly] { 
        background: #f9fafb; 
    } 
    .chk { 
        width: 16px; height: 16px; accent-color: var(--mi-accent); 
    } 
    .row-actions { 
        display: flex; gap: 6px; justify-content: flex-end; 
    } 
    .row-actions button { 
        padding: 6px 8px; 
        border-radius: 8px; 
        border: 1px solid var(--mi-border); 
        background: #fff; color: #334155; cursor: pointer; 
        transition: background 120ms ease, border-color 120ms ease, transform 80ms ease; 
    } 
    .row-actions button:hover { 
        background: var(--mi-subtle); border-color: #d1d5db; 
    } 
    .row-actions button:active { transform: translateY(1px); } 
    .row-actions button:disabled { 
        opacity: 0.6; 
        cursor: not-allowed;
    } 
    .empty { 
        color: var(--mi-muted); 
        padding: 12px; 
        text-align: center; 
    } 
    .tfoot { 
        padding: 10px 12px; border-top: 1px solid var(--mi-border); 
        background: #fff; 
    } 
    .primary { 
        border: 1px solid #1d4ed8; 
        background: var(--mi-accent); 
        color: #fff; 
        font-weight: 700; 
        border-radius: 8px; 
        padding: 8px 12px; 
        box-shadow: 0 2px 8px rgba(37, 99, 235, 0.25); 
    } 
    .primary:hover { 
        filter: brightness(1.05); 
    } 
</style>


=== ../dyna/src/WindowFrame.svelte ===
<script> 
    import { draggable } from './actions/draggable.js'; 
    import { resizable } from './actions/resizeable.js'; 
    let { 
        id, 
        title = 'Window', 
        position = $bindable({ x: 48, y: 48 }), 
        size = $bindable({ w: 420, h: 280 }), 
        z = 1, 
        minSize = { w: 320, h: 160 }, 
        onFocus: onFocusCb, 
        onRequestClose: onRequestCloseCb, children=undefined, headerActions=undefined 
    } = $props(); 
    let winEl = null; 
    function focusSelf() { 
        onFocusCb?.({ id }); 
    } 
    function requestClose() { 
        onRequestCloseCb?.({ id }); 
    } 
    function layerBounds() { 
        const layer = winEl?.parentElement; 
        return { 
            w: layer?.clientWidth ?? window.innerWidth, 
            h: layer?.clientHeight ?? window.innerHeight 
        }; 
    } 
</script> 

<div 
    class="window" 
    bind:this={winEl} 
    style={
        `transform: translate(${position.x}px, ${position.y}px); width:${size.w}px; height:${size.h}px; z-index:${z};`
    } 
    onfocusin={focusSelf} 
    onpointerdown={focusSelf} > 
    
    <div class="win-header" use:draggable={{ 
        get: () => position, 
        set: (p) => (position = p), 
        bounds: layerBounds, 
        getSize: () => size 
        }} > 
        <div class="win-title">{title}</div> 
        <div class="win-actions"> {#if headerActions} {@render headerActions()} {:else} <button class="win-close" type="button" onpointerdown={(e) => e.stopPropagation()} onclick={requestClose} aria-label="Close" > <svg viewBox="0 0 24 24" width="16" height="16" aria-hidden="true"> <path d="M6 6l12 12M18 6L6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" fill="none"/> </svg> </button> {/if} 
        </div> 
    </div> 
    <div class="win-body"> {@render children?.()} </div> 
    <div class="win-resize" use:resizable={{ get: () => size, set: (s) => (size = s), min: minSize, bounds: layerBounds, getPos: () => position }} aria-label="Resize corner" > </div>
</div>



<style> 
    .window { 
        --win-bg: #ffffff; 
        --win-border: #e5e7eb; 
        --win-radius: 12px; 
        --win-shadow: 0 10px 25px rgba(0,0,0,0.10), 0 8px 10px rgba(0,0,0,0.06); 
        --win-shadow-active: 0 16px 40px rgba(0,0,0,0.18); 
        --header-bg: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%); 
        --header-border: #1e40af; --header-text: #ffffff; /* Pass theme to children via vars if needed */ 
        --fi-accent: #2563eb; --fi-label: #111827; 
    } 
    .window { 
        position: absolute; 
        background: var(--win-bg); 
        border: 1px solid var(--win-border); 
        border-radius: var(--win-radius); 
        box-shadow: var(--win-shadow); 
        overflow: hidden; display: grid; 
        grid-template-rows: auto 1fr; 
        user-select: none; 
        transition: box-shadow 160ms ease, transform 160ms ease; 
        font: 400 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; 
    } 
    
    .window:focus-within, .window:active { 
        box-shadow: var(--win-shadow-active); 
    } 
    .win-header { 
        display: flex; 
        align-items: center; 
        justify-content: space-between; 
        gap: 8px; 
        padding: 8px 10px; 
        background: var(--header-bg); 
        border-bottom: 1px solid var(--header-border); 
        cursor: grab; 
        touch-action: none; 
        /* prevents scroll on touch while dragging */ 
    } 
    .win-header:active { 
        cursor: grabbing; 
    } 
    .win-title { 
        font-weight: 600; 
        font-size: 0.95rem; 
        color: var(--header-text); 
    } 
    .win-actions { 
        display: flex; gap: 6px; 
    } 
    .win-close { 
        inline-size: 28px; 
        block-size: 28px; 
        display: grid; 
        place-items: center; 
        border: 1px solid rgba(255,255,255,0.35); 
        background: rgba(255,255,255,0.16); 
        color: #fff; 
        border-radius: 8px; 
        cursor: pointer; 
        transition: background 140ms ease, transform 120ms ease, box-shadow 140ms ease; 
    } 
    .win-close:hover { 
        background: rgba(255,255,255,0.26); 
        box-shadow: 0 2px 6px rgba(0,0,0,0.1) inset; 
    } 
    .win-close:active { 
        transform: translateY(1px); 
    } 
    .win-body { 
        padding: 14px; 
        overflow: auto; 
        background: #fff; 
    } 
    .win-resize { 
        position: absolute; 
        right: 6px; 
        bottom: 6px; 
        inline-size: 14px; 
        block-size: 14px; 
        cursor: nwse-resize; 
        touch-action: none; /* better resize on touch */ 
    } 
    .win-resize::after { 
        content: ''; 
        position: absolute; 
        inset: 0; 
        background: linear-gradient(135deg, transparent 40%, #c7ccd1 40% 60%, transparent 60%) right bottom/100% 100% no-repeat; opacity: 0.8; 
    } 
</style>

=== ../dyna/src/RenderPlugin.svelte ===
<script> 

    import WindowFrame from './WindowFrame.svelte'; 
    let { w, onFocus: onFocusCb, onRequestClose: onRequestCloseCb } = $props(); 
    let Comp = $state(null); let loading = $state(false); 
    let error = $state(null); 

    async function load() { 
        loading = true; 
        error = null; 
        Comp = null; 
        try { 
            const url = `/plugins/${w.plugin.id}/${w.plugin.version}/index.js`; 
            const mod = await import(url); 
            Comp = mod?.default ?? null; 
        } catch (e) { 
            error = String(e); 
            console.log("here")
            console.log(error)
        } finally { 
            loading = false; 
        } 
    } 
    $effect(() => { if (w?.plugin?.id && w?.plugin?.version) load(); });
    function requestClose() { 
        onRequestCloseCb?.({ id: w.id, isDirty: false, value: null, persist: w.persist }); 
    } 
</script>




<WindowFrame id={w.id} title={w.title} bind:position={w.position} bind:size={w.size} z={w.z} onFocus={onFocusCb} onRequestClose={requestClose}>
    {#snippet children()}
    {#if error}<div class="err">{error}</div>
    {:else if loading}<div>Loading…</div>
    {:else if Comp}<Comp props={w.props ?? {}} />
    {/if}
    {/snippet}

</WindowFrame>



=== ../dyna/src/MetaDataWindow.svelte ===
<script> 
    import WindowFrame from './WindowFrame.svelte'; 
    import MetadataInterpreter from './MetaDataInterpreter.svelte'; 
    let { 
        id, 
        title = 'Metadata Editor', 
        value = $bindable({ entities: [] }), 
        disabled = false, 
        readOnly = false, 
        persist = 'keep', 
        position = $bindable({ x: 60, y: 60 }), 
        size = $bindable({ w: 900, h: 620 }), 
        z = 1, 
        confirmOnDirtyClose = true, 
        onFocus: onFocusCb, 
        onRequestClose: onRequestCloseCb, 
        debug = false 
    } = $props(); 
    let isDirty = false; 
    let initialSnapshot = ''; 
    let lastId = null; 
    $effect(() => { if (id !== lastId) { lastId = id; initialSnapshot = JSON.stringify(value ?? {}); isDirty = false; } });

    $effect(() => { isDirty = JSON.stringify(value ?? {}) !== initialSnapshot; }); 
    function handleSubmit({ value: v }) { 
        initialSnapshot = JSON.stringify(v ?? {}); isDirty = false; 
    } 
    function requestClose() { 
        onRequestCloseCb?.({ id, isDirty, value, persist, confirmOnDirtyClose }); 
    } 
</script>
<WindowFrame
    id={id}
    title={title}
    bind:position={position}
    bind:size={size}
    z={z}
    onFocus={onFocusCb}
    onRequestClose={requestClose} >

    {#snippet children()}
    <MetadataInterpreter bind:value={value} {disabled} {readOnly} onSubmit={handleSubmit} {debug} />
    {/snippet}

    {#snippet headerActions()}
    <div class="header-actions">
    <button type="button" class="win-close" onpointerdown={(e) => e.stopPropagation()} onclick={() => handleSubmit({ value })}>Save</button>
    <button type="button" class="win-close" onpointerdown={(e) => e.stopPropagation()} onclick={requestClose} aria-label="Close">×</button>
    </div>
    {/snippet}
</WindowFrame>

<style> .header-actions { display: flex; gap: 6px; } </style>


=== ../dyna/src/FormWindow.svelte ===
<script lang="ts"> 
    import WindowFrame from './WindowFrame.svelte'; 
    import FormInterpreter from './FormInterpreter.svelte'; 
    import { createEventDispatcher } from 'svelte'; 
    

    let { 
        id, 
        title = 'Form', 
        schema = [], 
        value = $bindable({}), 
        disabled = false, 
        readOnly = false, 
        persist = 'destroy',  
        position = $bindable({ x: 48, y: 48 }), 
        size = $bindable({ w: 420, h: 280 }),
        z = 1, transitions = true,
        confirmOnDirtyClose = true, 
        onSubmit: onSubmitCb, 
        onFocus: onFocusCb, 
        onRequestClose: onRequestCloseCb, 
        debug = false 
    } = $props(); 
    let isDirty = false; 
    let initialSnapshot = ''; 
    let lastId = null; 
    // Reset baseline only when the window id changes (or on mount) 
    $effect(() => { 
        if (id !== lastId) { 
            lastId = id; 
            initialSnapshot = JSON.stringify(value ?? {}); isDirty = false; 
        } 
    }); 


    $effect(() => { 
        const now = JSON.stringify(value ?? {}); 
        isDirty = now !== initialSnapshot; 
    });
    
     
    function handleSubmit({ value: v }) { 
        onSubmitCb?.({ id, value: v }); 
        initialSnapshot = JSON.stringify(value ?? {}); 
        isDirty = false; 
    } 
    function requestClose() { 
        onRequestCloseCb?.({ id, isDirty, value, persist, confirmOnDirtyClose }); 
    } 
</script>


<WindowFrame
    id={id}
    title={title}
    bind:position={position}
    bind:size={size}
    z={z}
    onFocus={onFocusCb}
    onRequestClose={requestClose} >

    {#snippet children()}
        <FormInterpreter
            {schema}
            bind:value={value}
            {disabled}
            {readOnly}
            onSubmit={handleSubmit}
            {debug}
            />
    {/snippet}

    {#snippet headerActions()}
        <button
            class="win-close"
            type="button"
            onpointerdown={(e) => e.stopPropagation()}
            onclick={requestClose}
            aria-label="Close"
        >×</button>
    {/snippet}
</WindowFrame>


=== ../dyna/src/SubmitButton.svelte ===
<script>
  export let label = "Submit";
</script>
<button type="submit">{label}</button>


=== ../dyna/src/registry.js ===
import InputField from './InputField.svelte';
import SubmitButton from './SubmitButton.svelte';
import GroupField from './GroupField.svelte';

export default {
  input: InputField,
  submit: SubmitButton,
  group: GroupField, // Enables registration logic if you want `group` in registry
};


=== ../dyna/src/GroupField.svelte ===
<!-- GroupField.svelte -->
<script>
  import FormInterpreter from './FormInterpreter.svelte';
  export let label = "";
  export let fields = [];
  export let values = {};
  export let onChange = () => {};
</script>

<fieldset>
  <legend>{label}</legend>
  {#each fields as field}
    <FormInterpreter
      node={field}
      values={values}
      
    />
  {/each}
</fieldset>


=== ../dyna/src/MetaDataInterpreter.svelte ===
<script> 
    import AttributesTable from './Attributes.svelte'; 
    let { 
        value = $bindable({ entities: [] }), 
        disabled = false, 
        readOnly = false, 
        debug = false, 
        onSubmit: onSubmitCb 
    } = $props(); 
    let selectedIndex = $state(0); 
    function ents() { 
        return value.entities ?? (value.entities = []); 
    } 
    let current = $derived(ents()[selectedIndex]); 
    function addEntity() { 
        const next = [...ents(), { schema_name: 'new_schema', attributes: [] }]; 
        value = { ...value, entities: next }; selectedIndex = next.length - 1; 
    } 
    function duplicateEntity(i) { 
        const src = ents()[i]; 
        if (!src) return; 
        const copy = JSON.parse(JSON.stringify(src)); 
        copy.schema_name = `${src.schema_name}_copy`; 
        const next = [...ents(), copy]; 
        value = { ...value, entities: next }; 
        selectedIndex = next.length - 1; 
    } 
    function deleteEntity(i) { 
        if (!window.confirm('Delete this entity?')) return; 
        const next = ents().filter((_, idx) => idx !== i); 
        value = { ...value, entities: next.length ? next : [{ schema_name: 'new_schema', attributes: [] }] }; 
        selectedIndex = 0; 
    } 
    function submit() { onSubmitCb?.({ value }); } 
</script> 

<div class="root"> 
    <aside class="sidebar"> 
        <div class="side-header"> 
            <h2>Schemas</h2> 
            <button class="primary" type="button" onclick={addEntity} disabled={disabled || readOnly}>+ Add</button> 
        </div>
<ul class="entity-list">
  {#each ents() as e, i (i)}
    <li class:selected={i === selectedIndex} onclick={() => (selectedIndex = i)}>
      <div class="name">{e.schema_name || '(unnamed)'}</div>
      <div class="count">{e.attributes?.length || 0} attrs</div>
      <div class="row-actions" onclick={(e) => e.stopPropagation()}>
        <button  title="Duplicate" onclick={() => duplicateEntity(i)} disabled={disabled || readOnly}>⧉</button>
        <button title="Delete" onclick={() => deleteEntity(i)} disabled={disabled || readOnly}>✕</button>
      </div>
    </li>
  {/each}
</ul>

<div class="side-footer">
  <button onclick={submit} disabled={disabled}>Save</button>
</div>
</aside> <main class="editor"> {#if current} <div class="entity-header"> <div class="field"> <label>Schema Name</label> <input type="text" bind:value={current.schema_name} oninput={() => (value = { ...value })} placeholder="e.g., order" disabled={disabled} readonly={readOnly} /> </div> </div>
  <AttributesTable bind:rows={current.attributes} {disabled} {readOnly} />
{/if}

{#if debug}
  <pre class="debug">{JSON.stringify(value, null, 2)}</pre>
{/if}
</main> 
</div> 
<style> 
/* Theme hooks (inherits --fi-accent from WindowFrame) */ 
    :root { 
        --mi-bg: #ffffff; --mi-border: #e5e7eb; --mi-subtle: #f8fafc; --mi-muted: #6b7280; --mi-text: #111827; --mi-accent: var(--fi-accent, #2563eb); 
        --mi-accent-weak: rgba(37, 99, 235, 0.12); --mi-radius: 10px; 
    } 
     
    .root { 
        display: grid; 
        grid-template-columns: 280px 1fr; 
        height: 100%; 
        color: var(--mi-text); background: var(--mi-bg); 
    } 
    
    /* Sidebar */ 
    .sidebar { 
        display: flex; 
        flex-direction: column; 
        border-right: 1px solid var(--mi-border); 
        background: #fff; min-width: 240px; 
    } 
    .side-header { 
        display: flex; 
        align-items: center; 
        justify-content: space-between; 
        gap: 8px; 
        padding: 12px; 
        border-bottom: 1px solid var(--mi-border); 
    } 
    .side-header h2 { 
        margin: 0; 
        font-size: 0.95rem; 
        font-weight: 700; 
        color: #0f172a; 
    } 
    .entity-list { 
        list-style: none; 
        margin: 0; 
        padding: 0; 
        overflow: auto; 
        flex: 1; 
        background: #fff; 
    } 
    .entity-list li { 
        display: grid; 
        grid-template-columns: 1fr auto auto; 
        gap: 8px; 
        padding: 10px 12px; 
        align-items: center; 
        border-bottom: 1px solid #f3f4f6; 
        background: #fff; 
        cursor: pointer; 
        border-left: 3px solid transparent; 
        transition: background 120ms ease, border-color 120ms ease; 
    } 
    .entity-list li:hover { 
        background: var(--mi-subtle); 
    } 
    .entity-list li.selected { 
        background: #eff6ff; 
        border-left-color: var(--mi-accent); 
    } 
    .entity-list .name { 
        font-weight: 600; 
        overflow: hidden; 
        text-overflow: ellipsis; 
        white-space: nowrap; 
    } .entity-list 
    .count { 
        font-size: 12px; 
        color: var(--mi-muted); 
    } 
    .entity-list .row-actions { display: flex; gap: 6px; } 
    .entity-list .row-actions button { 
        padding: 6px 8px; 
        line-height: 1; 
        border-radius: 8px; 
        border: 1px solid var(--mi-border); background: #fff; 
        color: #334155; 
        cursor: pointer; 
        transition: background 120ms ease, border-color 120ms ease, transform 80ms ease; 
    } 
    .entity-list .row-actions button:hover { 
        background: var(--mi-subtle); border-color: #d1d5db; 
    } 
    .entity-list .row-actions button:active { 
        transform: translateY(1px); 
    } 
    .entity-list .row-actions button:disabled { 
        opacity: 0.6; cursor: not-allowed; 
    } 
    .side-footer { 
        padding: 12px; 
        border-top: 1px solid var(--mi-border); background: #fff; 
    } 
    /* Main editor */ 
    .editor { 
        background: #fff; 
        padding: 14px; 
        overflow: auto; 
    } 
    .entity-header { 
        display: grid; 
        gap: 10px; 
        margin: 4px 0 12px; 
    } 
    label { 
        display: block; 
        font-size: 12px; 
        color: var(--mi-muted); 
        margin-bottom: 6px; 
    } 
    input[type="text"] { 
        width: 100%; 
        padding: 10px 12px; 
        border: 1px solid #d1d5db; 
        border-radius: var(--mi-radius); 
        background: #fff; 
        color: var(--mi-text); 
        outline: none; 
        transition: border-color 120ms, box-shadow 120ms, background-color 120ms; 
    } 
    input[type="text"]::placeholder { 
        color: #9ca3af; 
    } 
    input[type="text"]:focus { 
        border-color: var(--mi-accent); 
        box-shadow: 0 0 0 3px var(--mi-accent-weak); 
    } 
    input[readonly] { 
        background: #f9fafb; 
    } 
    /* Buttons (shared) */ 
    button { 
        padding: 8px 10px; 
        border-radius: 8px; 
        border: 1px solid #d1d5db; 
        background: #fff; 
        color: #111827; 
        cursor: pointer; 
        transition: background 120ms ease, border-color 120ms ease, transform 80ms ease, box-shadow 120ms ease; 
    } 
    button:hover { 
        background: #f8fafc; 
        border-color: #cfd6dd; 
    } 
    button:active { 
        transform: translateY(1px); 
    } 
    button:disabled { 
        opacity: 0.6; 
        cursor: not-allowed; 
    } 
    button.primary { 
        border-color: #1d4ed8; 
        background: var(--mi-accent); 
        color: #fff; 
        font-weight: 700; 
        box-shadow: 0 2px 8px rgba(37, 99, 235, 0.25); 
    } 
    button.primary:hover { filter: brightness(1.05); } 
    /* Debug block */ 
    .debug { 
        margin-top: 12px; 
        background: #0b1020; 
        color: #d1e7ff; 
        padding: 10px; 
        border-radius: 10px; 
        font-size: 12px; 
        overflow: auto; 
    } 
</style>


=== ../dyna/src/SelectField.svelte ===
<script>
  export let label = "";
  export let name = "";
  export let options = [];
</script>
<label>
  {label}
  <select name={name}>
    {#each options as opt}
      <option value={opt}>{opt}</option>
    {/each}
  </select>
</label>



=== ../dyna/src/lib/Counter.svelte ===
<script>
  let count = $state(0)
  const increment = () => {
    count += 1
  }
</script>

<button onclick={increment}>
  count is {count}
</button>


=== ../dyna/src/actions/draggable.js ===
export function draggable(node, options = {}) {
    let opts = {
    // get current pos { x, y }
    get: () => ({ x: 0, y: 0 }),
    // set new pos
    set: (_pos) => {},
    // optional: () => ({ w, h }) of the container (canvas/windows layer)
    bounds: undefined,
    // optional: () => ({ w, h }) of the window; if omitted, uses node.offsetWidth/Height
    getSize: undefined,
    ...options
    };

    let active = false;
    let startPointer = { x: 0, y: 0 };
    let startPos = { x: 0, y: 0 };
    let raf = 0;

    function isInteractiveTarget(el) {
        return el.closest?.('button, a, input, textarea, select, label, [role="button"], [contenteditable], [data-nodrag]');
    }

    function onPointerDown(e) {
        if (e.button !== 0) return;
        if (isInteractiveTarget(e.target)) return; // don’t start drag from close button, etc.
        e.preventDefault();
        active = true;
        startPointer = { x: e.clientX, y: e.clientY };
        startPos = opts.get();
        node.setPointerCapture?.(e.pointerId);
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
    }

    function onPointerMove(e) {
        if (!active) return;
        const dx = e.clientX - startPointer.x;
        const dy = e.clientY - startPointer.y;
        let x = startPos.x + dx;
        let y = startPos.y + dy;

        const b = opts.bounds?.();
        if (b) {
            const size = opts.getSize?.() ?? { w: node.offsetWidth, h: node.offsetHeight };
            const bw = b.w ?? b.width ?? 0;
            const bh = b.h ?? b.height ?? 0;
            x = Math.min(Math.max(0, x), Math.max(0, bw - size.w));
            y = Math.min(Math.max(0, y), Math.max(0, bh - size.h));
        }

        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => opts.set({ x, y }));
    }

    function onPointerUp(e) {
        active = false;
        try { 
            node.releasePointerCapture?.(e.pointerId); 
        } catch {}
        window.removeEventListener('pointermove', onPointerMove);
        window.removeEventListener('pointerup', onPointerUp);
        cancelAnimationFrame(raf);
    }

    node.addEventListener('pointerdown', onPointerDown);

    return {
        update(newOptions = {}) { opts = { ...opts, ...newOptions }; },
        destroy() {
        node.removeEventListener('pointerdown', onPointerDown);
        window.removeEventListener('pointermove', onPointerMove);
        window.removeEventListener('pointerup', onPointerUp);
        cancelAnimationFrame(raf);
        }
    };
}



=== ../dyna/src/actions/resizeable.js ===
export function resizable(node, options = {}) {
    let opts = {
    // get current size { w, h }
    get: () => ({ w: 0, h: 0 }),
    // set new size
    set: (_size) => {},
    // optional: min size
    min: { w: 160, h: 120 },
    // optional: () => ({ w, h }) of the container
    bounds: undefined,
    // optional: current position { x, y } to clamp size to container
    getPos: undefined,
    ...options
    };

    let active = false;
    let startPointer = { x: 0, y: 0 };
    let startSize = { w: 0, h: 0 };
    let raf = 0;

    function onPointerDown(e) {
        if (e.button !== 0) return;
        e.preventDefault();
        active = true;
        startPointer = { x: e.clientX, y: e.clientY };
        startSize = opts.get();
        node.setPointerCapture?.(e.pointerId);
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
    }

    function onPointerMove(e) {
        if (!active) return;
        const dx = e.clientX - startPointer.x;
        const dy = e.clientY - startPointer.y;
        let w = Math.max(opts.min.w, startSize.w + dx);
        let h = Math.max(opts.min.h, startSize.h + dy);

        const b = opts.bounds?.();
        const pos = opts.getPos?.();
        if (b && pos) {
            const bw = b.w ?? b.width ?? 0;
            const bh = b.h ?? b.height ?? 0;
            const maxW = Math.max(0, bw - pos.x);
            const maxH = Math.max(0, bh - pos.y);
            w = Math.min(w, maxW);
            h = Math.min(h, maxH);
        }

        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => opts.set({ w, h }));
    }

    function onPointerUp(e) {
        active = false;
        try { node.releasePointerCapture?.(e.pointerId); } catch {}
        window.removeEventListener('pointermove', onPointerMove);
        window.removeEventListener('pointerup', onPointerUp);
        cancelAnimationFrame(raf);
    }

    node.addEventListener('pointerdown', onPointerDown);

    return {
        update(newOptions = {}) { opts = { ...opts, ...newOptions }; },
        destroy() {
            node.removeEventListener('pointerdown', onPointerDown);
            window.removeEventListener('pointermove', onPointerMove);
            window.removeEventListener('pointerup', onPointerUp);
            cancelAnimationFrame(raf);
        }
    };
}

=== ../dyna/src/windows/RenderForm.svelte ===
<script> 
    import FormWindow from '../FormWindow.svelte'; 
    export let w; 
    export let onFocus; 
    export let onRequestClose; 
    export let onSubmit; 
    export let transitions = true; 
</script>

<FormWindow
    id={w.id}
    title={w.title}
    schema={w.schema}
    bind:value={w.value}
    persist={w.persist}
    bind:position={w.position}
    bind:size={w.size}
    z={w.z}
    {transitions}
    onSubmit={onSubmit}
    onRequestClose={onRequestClose}
    onFocus={onFocus}
/>



=== ../dyna/src/windows/RenderMetadata.svelte ===
<script> 
    import MetaDataWindow from '../MetaDataWindow.svelte'; 
    export let w; 
    export let onFocus; 
    export let onRequestClose; 
</script>

<MetaDataWindow
    id={w.id}
    title={w.title}
    bind:position={w.position}
    bind:size={w.size}
    z={w.z}
    persist={w.persist}
    bind:value={w.value}
    onFocus={onFocus}
    onRequestClose={onRequestClose}
/>


=== ../dyna/src/windows/registry.js ===
import RenderForm from './RenderForm.svelte';
import RenderChat from './RenderChat.svelte';
import RenderMetadata from './RenderMetadata.svelte';

export const WINDOW_RENDERERS = {
    form: RenderForm,
    chat: RenderChat,
    metadata: RenderMetadata
};


=== ../dyna/src/windows/RenderChat.svelte ===
<script> 
    import ChatWindow from '../ChatWindow.svelte'; 
    export let w; 
    export let onFocus; 
    export let onRequestClose; 
</script>

<ChatWindow
    id={w.id}
    title={w.title}
    bind:position={w.position}
    bind:size={w.size}
    z={w.z}
    persist={w.persist}
    config={w.chatConfig}
    bind:messages={w.messages}
    chatType={w.chatType}
    onFocus={onFocus}
    onRequestClose={onRequestClose}
/>



